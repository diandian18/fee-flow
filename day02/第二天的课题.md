# 前端监控系统的搭建

## 1. 前端监控系统架构

在介绍灯塔之前，我们首先设计一下我们的系统架构

![前端监控系统架构图](../assets/fee-flow.png)

总体上我们的架构由6个大的部分组成：

1. `sdk`安装在前端业务项目中，用来采集错误、性能、业务等信息并上报到`打点服务`
2. `dig server`即`打点服务`，用来提供一个`空gif`的`nginx`服务，并且利用`nginx`生成`日志文件`，另外需要一个`filebeat`，来监听这些日志文件，并将这些文件内容发送到`kafka`消息队列
3. `kafka`是分布式发布-订阅消息系统，`kafka`会接受`生产者(producer)`的消息，并且把消息发送给订阅消息的`消费者(consumer)`。上面的`filebeat`就是生产者，而下面的`消费服务`就是消费者
4. `server`包含两部分
    1. 我们需要一个`消费服务`，用来消费kafka的日志消息，并且对这些日志做格式校验、聚合等操作后落入`mysql`数据库持久化。
    2. 另外还需要一个`rest api`服务，对错误、性能、业务等信息做可视化展示用
5. `mysql`和`redis`，对消费后的数据做持久化和缓存
6. `可视化展示client`直观展示监控到的数据

## 2. fee介绍

> [fee（灯塔）](https://github.com/LianjiaTech/fee) 是前端监控系统，贝壳找房主要前端监控系统，服务公司上百条产品线。 特点：架构简单、轻量、支持私有化部署。可收集前端设备、系统、环境信息， 可以对前端页面js报错、资源错误、性能指标进行配置报警等， 并且可以通过上报错误信息引导用户快速定位解决问题。

灯塔项目提供了架构中`sdk`、`server`和`client`三个部分，其他部分`dig server`、`kafka`和`mysql/redis`，需要我们自行开发或搭建。

## 3. fee仓库

我们首先`clone`仓库到本地：

```bash
git clone https://github.com/LianjiaTech/fee
cd fee
```

可以看到，fee仓库由`sdk`、`server`和`client`三个部分组成。

```bash
├── README.md
├── sdk
├── server
└── client
```

我们可以稍微花点时间过一下仓库的代码，了解下代码结构，使用方式和运行原理。这里先不做展开。

## 4. 配置nginx

在运行起来fee各部分之前，我们先搭建好各节点环境，主要包括`打点服务nginx`、`filebeat`、`kafka`、`mysql`、`redis`等。

### 4.1 为什么打点服务选择nginx

首先我们直接开始搭建打点服务，打点服务使用nginx即可，原因：

1. 一方面因为它自带空gif图片服务模块
2. 另一方面可以打log

### 4.2 下载nginx

```bash
yum install -y nginx
```

### 4.3 配置nginx

1. 利用nginx自带的empty_gif模块，配置一个空gif的静态资源服务
2. 配置日志格式`log_format`
3. 配置日志存放路径`access_log`

```bash
vim /etc/nginx/nginx.conf
```

```bash
# /etc/nginx/nginx.conf
log_format ferms '$time_iso8601     -       -       $remote_addr    $http_host      $status $request_time   $request_length $body_bytes_sent        15d04347-be16-b9ab-0029-24e4b66459509689c3ea-5155-2df7-a719-e90d2dedeb2c 937ba755-116a-18e6-0735-312cba23b00c        -       -       $request_uri    -       $http_user_agent        -       sample=-&_UC_agent=-&device_id=-&-  -';
http {
    server {
        listen 80;
        server_name ferms.xxx.com;
        return 301 https://ferms.xxx.com$request_uri;
    }
    server {
        listen 443 ssl;
        server_name ferms.xxx.com;

        ssl_certificate      /etc/nginx/ssl/xxx.crt;
        ssl_certificate_key  /etc/nginx/ssl/xxx.key;

        if ($time_iso8601 ~ "^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2})") {
            set $year $1;
            set $month $2;
            set $day $3;
            set $hour $4;
            set $minute $5;
        }
        access_log /var/log/nginx/ferms/$year$month-$day-$hour-$minute.log ferms;
        location = /dig.gif {
            empty_gif;
        }
    }
}
```

另外需要：

1. 新建一个nginx日志存放的文件夹

    ```bash
    mkdir -p /var/log/nginx/ferms
    ```

2. 启动nginx的用户，对这个文件夹有读写权限

    ```bash
    chown -R nginx:nginx /var/log/nginx/ferms
    chmod -R 644 /var/log/nginx/ferms
    ll /var/log/nginx/ferms
    # -rw-r--r-- 1 nginx nginx 14201 Sep  1 14:35 202009-01-14-35.log
    ```

3. dig-log的日志，为防止占满磁盘，需要定期清除，可以设置时间间隔为1到3天

    1. 编写删除nginx日志的脚本`delete_nginx_logs.sh`，删除`/var/log/nginx`下的昨日的日志

        ```bash
        mkdir -p /root/shell
        cd /root/shell
        vim delete_nginx_logs.sh
        ```

        ```bash
        #!/bin/bash
        #Filename:delete_nginx_logs.sh
        LOGS_PATH=/var/log/nginx
        KEEP_DAYS=30
        PID_FILE=/run/nginx.pid
        YESTERDAY=$(date -d "yesterday" +%Y-%m-%d)
        if [ -f $PID_FILE ];then
            echo `date "+%Y-%m-%d %H:%M:%S"` 开始删除日志...
            mv ${LOGS_PATH}/access.log ${LOGS_PATH}/access.${YESTERDAY}.log >/dev/null 2>&1
            mv ${LOGS_PATH}/access.json ${LOGS_PATH}/access.${YESTERDAY}.json >/dev/null 2>&1
            mv ${LOGS_PATH}/error.log ${LOGS_PATH}/error.${YESTERDAY}.log >/dev/null 2>&1
            kill -USR1 `cat $PID_FILE`
            echo `date "+%Y-%m-%d %H:%M:%S"` 日志删除完成.
        else
            echo `date "+%Y-%m-%d %H:%M:%S"` 请确认nginx是否运行...
        fi
        echo

        find $LOGS_PATH -type f -mtime +$KEEP_DAYS -print0 |xargs -0 rm -f
        ```

    2. `touch delete_nginx_logs.log`新建日志文件，用来记录脚本运行日志

    3. 新建定时任务

    ```bash
    crontab -e
    ```

    ```bash
    # `crontab -e`进入当前用户的工作表编辑，是常见的vim界面。每行是一条命令。
    # 每天00点00分，运行shell脚本，把shell脚本的标准错误输出重定向到标准输出，并把输出追加到log文件中
    00 00 * * * /bin/bash /root/shell/cut_nginx_logs.sh >>/root/shell/cut_nginx_logs.log 2>&1
    ```

### 4.4 启动Nginx并设置开机自动运行

```bash
sudo systemctl start nginx.service
sudo systemctl enable nginx.service
```

### 4.5 测试nginx服务

1. 访问`https://ferms.xxx.com/dig.gif?a=1`
2. 观察`/var/log/nginx/ferms/`文件夹下是否产生日志文件，例如`202009-01-14-35.log`
3. 观察文件内容格式是否符合预期，正常的格式如下：

    ```bash
    2020-09-02T17:01:56+08:00       -       -       115.236.3.131   ferms.bestsign.info     200     0.000   1472    43      15d04347-be16-b9ab-0029-24e4b6645950    -       -       9689c3ea-5155-2df7-a719-e90d2dedeb2c 937ba755-116a-18e6-0735-312cba23b00c    -       -       /dig.gif?d=%7B%22type%22%3A%22product%22%2C%22code%22%3A10001%2C%22detail%22%3A%7B%22duration_ms%22%3A5729%7D%2C%22extra%22%3A%7B%7D%2C%22common%22%3A%7B%22pid%22%3A%22bestsign-log-service-frontend%22%2C%22uuid%22%3A%22089975%22%2C%22ucid%22%3A%22%22%2C%22env%22%3A%22testing%22%2C%22is_test%22%3Afalse%2C%22record%22%3A%7B%22time_on_page%22%3Atrue%2C%22performance%22%3Atrue%2C%22js_error%22%3Atrue%2C%22js_error_report_config%22%3A%7B%22ERROR_RUNTIME%22%3Atrue%2C%22ERROR_SCRIPT%22%3Atrue%2C%22ERROR_STYLE%22%3Atrue%2C%22ERROR_IMAGE%22%3Atrue%2C%22ERROR_AUDIO%22%3Atrue%2C%22ERROR_VIDEO%22%3Atrue%2C%22ERROR_CONSOLE%22%3Atrue%2C%22ERROR_TRY_CATCH%22%3Atrue%7D%7D%2C%22version%22%3A%221.0.0%22%2C%22timestamp%22%3A1599037316091%2C%22runtime_version%22%3A%221.0.0%22%2C%22sdk_version%22%3A%221.0.41%22%2C%22page_type%22%3A%22https%3A%2F%2Flogservice.bestsign.info%2Findex%23%2Flogservice%2FlogSearch%2Fbestsign_log_data_source%2Fbestsign-v4-logs%2Faggregation-manager%22%7D%7D -       Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML,like Gecko) Chrome/80.0.3987.122 Safari/537.36  -       sample=-&_UC_agent=-&device_id=-&-      -       -       -
    ```
